@namespace NodeView.Pages 
@page "/nodes/networkview"
@inject HttpClient Http
@using Blazor.Diagrams.Components;
@using Blazor.Diagrams;
@using Blazor.Diagrams.Core.PathGenerators;
@using Blazor.Diagrams.Core.Routers;
@using Blazor.Diagrams.Options;
@using Blazor.Diagrams.Core.Models;   
@using Blazor.Diagrams.Core.Geometry;
@using Blazor.Diagrams.Core.Models.Base;
@using Blazor.Diagrams.Components.Widgets;
@using System.Net.Http.Json
@using SharedService;
@inject Blazored.LocalStorage.ILocalStorageService localStorage

<PageTitle>Network Viewer</PageTitle>

<h1>Network Viewer</h1>

<NodeView.Components.NetworkState />

@if (nodes == null)
{
    <p><em>Loading Network Information...</em></p>
}
else
{
<div style="width: 80%;
    height: 800px;
    border: 1px solid black;">
    <CascadingValue Value="diagram" IsFixed="true">
        <DiagramCanvas>        
        </DiagramCanvas>
    </CascadingValue>

    Out Messages  @System.Text.Json.JsonSerializer.Serialize(out_messages);

</div>

@if (history != null) {
    @foreach (ActiveActions actions in history.get_active_actions()) {
        @if (actions.ids != null && actions.ids.Count > 0) {
            <a>Nodes running @actions.type_id</a> <b>: @actions.ids.Count</b> 
            <b> ( @actions.ids.GroupBy(i => i).Count() unique ) </b>
         <br/>
        }
    }
}



}

@code {
    private LitContracts.Staking.ContractDefinition.Validator[]? nodes;
    private BlazorDiagram diagram { get; set; } = null;
    PeriodicTimer periodicTimer = new (TimeSpan.FromMilliseconds(500));
    private List<Metric>? node_averages;
    private  NetworkHistory? history;

    private List<OutMessages>? out_messages;
    protected override async Task OnInitializedAsync()
    {                
        var resolver = new Resolver(localStorage);
        var stakingService = await resolver.GetStakingService();
        
        var validators = await stakingService.GetValidatorsStructsInCurrentEpochQueryAsync();   
        nodes = validators.ReturnValue1.Select(x => new LitContracts.Staking.ContractDefinition.Validator
            {
                Ip = x.Ip,
                Ipv6 = x.Ipv6,
                NodeAddress = x.NodeAddress,
                Port = x.Port,
            }).ToArray();

        var options = new BlazorDiagramOptions
        {
            AllowMultiSelection = true,
            Zoom =
            {
                Enabled = false,
            },
            Links =
            { 
                DefaultRouter = new NormalRouter(),
                DefaultPathGenerator = new SmoothPathGenerator()
            },
        };

        diagram = new BlazorDiagram(options);

        var center_point = new Blazor.Diagrams.Core.Geometry.Point(450, 450);
        var node_count = nodes.Length;
        var positions = GetCirclePoints(node_count, 400, center_point);
        
        @* var inner_positions = GetCirclePoints(node_count , 350, center_point);
        var outer_positions = GetCirclePoints(node_count , 450, center_point); *@

        for (int i = 0; i < node_count; i++)
        {
            var node = diagram.Nodes.Add(new NodeModel(id: i.ToString(), position: positions[i])
            {
                Title = "Node " + nodes[i].Port.ToString(),

            });

        }


        for (int i = 0; i < node_count; i++)
        {
            for (int j = i; j < node_count; j++)
            {
                if (i == j)
                {
                    continue;
                }


                var link_id = i.ToString() + "-" + j.ToString();
                var link = diagram.Links.Add(new LinkModel( link_id , diagram.Nodes[i], diagram.Nodes[j]));                                 
                link.PathGenerator = new SmoothPathGenerator();
                link.TargetMarker = LinkMarker.Arrow;
                link.Width = 5;


                var link_id2 = j.ToString() + "-" + i.ToString();
                var targetAnchor = new Blazor.Diagrams.Core.Anchors.LinkAnchor(link, 20, 10,10);
                var sourceAnchor = new Blazor.Diagrams.Core.Anchors.ShapeIntersectionAnchor(diagram.Nodes[j]  );
                var link2 = diagram.Links.Add(new LinkModel(link_id2, diagram.Nodes[j], diagram.Nodes[i]));                                 
                link2.PathGenerator = new SmoothPathGenerator();                
                link2.TargetMarker = LinkMarker.Arrow;
                link2.Width = 3;
                
                var x = (diagram.Nodes[j].Position.X + diagram.Nodes[i].Position.X) / 2;
                var y = (diagram.Nodes[j].Position.Y + diagram.Nodes[i].Position.Y) / 2;
                var point = new Blazor.Diagrams.Core.Geometry.Point(x, y);
                
                var length = Math.Sqrt(Math.Pow(diagram.Nodes[j].Position.X - diagram.Nodes[i].Position.X, 2) + Math.Pow(diagram.Nodes[j].Position.Y - diagram.Nodes[i].Position.Y, 2)   );
                var offset_length = 20; //length / 10;
                var offset_x = (diagram.Nodes[j].Position.X - diagram.Nodes[i].Position.X) / length * offset_length;
                var offset_y = (diagram.Nodes[j].Position.Y - diagram.Nodes[i].Position.Y) / length * offset_length;

                var inner_point = new Blazor.Diagrams.Core.Geometry.Point(x - offset_y, y + offset_x);
                var vertex1 = link.AddVertex( inner_point );
                

                var outer_point = new Blazor.Diagrams.Core.Geometry.Point(x + offset_y, y - offset_x);
                var vertex2 = link2.AddVertex( outer_point );

            }
         
        } 

            history = new NetworkHistory(5, nodes.Length);
        RunTimer();
    }

    public List<Blazor.Diagrams.Core.Geometry.Point> GetCirclePoints(int points, double radius, Blazor.Diagrams.Core.Geometry.Point center)
    {
        double slice = 2 * Math.PI / points;
        var pointsList = new List<Blazor.Diagrams.Core.Geometry.Point>();
        for (int i = 0; i < points; i++)
        {
            double angle = slice * i;
            int newX = (int)(center.X + radius * Math.Cos(angle));
            int newY = (int)(center.Y + radius * Math.Sin(angle));
            Blazor.Diagrams.Core.Geometry.Point p = new Blazor.Diagrams.Core.Geometry.Point(newX, newY);
            pointsList.Add(p);
        }
        return pointsList;
    }

 async void RunTimer()
    {
        while (await periodicTimer.WaitForNextTickAsync()) { 
            HttpClient client = new HttpClient();
            List<NodeMetricRoot> new_metrics = new List<NodeMetricRoot>();
            List<Task> handles = new List<Task>();
            if(nodes != null) {
                foreach ( var node in nodes ) {

                    var handle = Task.Run(async () => {
                        var response = await client.GetAsync("http://localhost:" + node.Port.ToString() +  "/web/rt/metrics");
                        if (response.StatusCode == System.Net.HttpStatusCode.OK) {
                            var result = await response.Content.ReadAsStringAsync();
                            var current_metrics = System.Text.Json.JsonSerializer.Deserialize<NodeMetricRoot>(result);
                            if (current_metrics != null) {
                                new_metrics.Add(current_metrics);
                            }                            
                        }
                    });

                    handles.Add(handle);

                }
            }            

            await Task.WhenAll(handles);

            history.add(new_metrics);
            @* var net_average = history.network_average(); *@
            @* node_averages = history.node_average();             *@
            out_messages = history.get_out_messages();

            foreach (LinkModel link in diagram.Links) {
                var out_message = out_messages.First(x => x.name == link.Id);
                if (out_message == null) {
                    link.Color = "#CCCCCC";
                }
                else 
                {
                    link.Color = get_spectrum_color(out_message.count);
                }
                link.Refresh();
            }
            StateHasChanged();           
        }     
    }
    private string get_spectrum_color(int value) {
        switch (value) {
            case < 5:                
                return "#575957";
            case < 15:                
                return "#567051";
            case < 45:                
                return "#55914b";
            case < 75:        
                return "#4aaf3a";
            case < 100:
                return "#3ec729";
            case >= 100 :
                return "#25ff00";
        }
    }

    public void Dispose()
    {
        periodicTimer.Dispose(); 
    }  
}
